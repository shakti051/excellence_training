	Sorting is stable if it maintains relative order of duplicate elements.
	Sorting is In-place if space complexity is O(1) , it doesn't require any extra space.
	

1.	/**Selection Sort**/
        /**This is unstable sort,UnAdaptive  n time complexity os O(N)square**/
    public static void main(String[] args) {
        	int arr[]= {4, 5, 6, 2, 1, 7, 10, 3, 8, 9};
        	for (int i =0;i<arr.length;i++){
        	    for (int j=i+1;j<arr.length;j++){
        	        if (arr[i]>arr[j]){
        	            int temp = arr[i];
        	            arr[i] = arr[j];
        	            arr[j]=temp;
                    }else break;
                }
            }
        /**Printing the array**/
        for (int i=0;i<arr.length;i++)
            System.out.print(arr[i]+" ");
    }

2. /**Bubble Sort**/
    /** Each element is compared with neighbour and swapped if required
     * It is stable n Adaptive sort. Run time complexity O(N)square n space complexity O(1)
     * **/
    public static void main(String[] args) {
        int arr[]= {4, 5, 6, 2, 1, 7, 10, 3, 8, 9};
        for (int i =0;i<arr.length;i++){
                boolean swapped = false;
            for (int j=0;j<arr.length-1-i;j++){
                if (arr[j]>arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1]=temp;
                    swapped = true;
                }
            }
            if (!swapped) break;
        }

        /**Printing the array**/
        for (int i=0;i<arr.length;i++)
            System.out.print(arr[i]+" ");
    }

3. /**Insertion Sort**/
    /***This is in-place means space complexity O(1) , doese't require to make copy of array.
     * This is stable sort,Adaptive n time complexity is O(N)square**/
    
    public static void main(String[] args) {
        int arr[]= {4, 5, 6, 2, 1, 7, 10, 3, 8, 9};
        for (int i =0;i<arr.length-1;i++){  /**Go upto second last element**/
            for (int j=i+1;j>0;j--){
                if (arr[j-1]>arr[j]){
                    int temp = arr[j-1];
                    arr[j-1] = arr[j];
                    arr[j]=temp;
                }
            }
        }

        /**Printing the array**/
        for (int i=0;i<arr.length;i++)
            System.out.print(arr[i]+" ");
    }

4. Merge Sort is not In-Place , run time complexiy is O(nLogn)base 2, this spable sort means relative ordering of 		   dublicate items is preserved.

#include<stdio.h>
#include<conio.h>
#define MAX 100

void mergesort(int a[],int low,int up);
void merge(int a[],int temp[],int low1,int up1,int low2,int up2);
void copy(int a[],int temp[],int low,int up);


int main()
{
    int a[MAX],n,i;
    
    printf("Enter the no of elements in  array: ");
    scanf("%d",&n);
    printf("Enter elements in order: \n");
    for(i=0;i<n;i++)
    {
       printf("Enter the element %d :",i+1);
       scanf("%d",&a[i]);
    }

    mergesort(a,0,n-1);
    printf("Sorted list  is: \n");
    for(i=0;i<n;i++)
     printf("%d ",a[i]);
     printf("\n");

getch();
}

void mergesort(int a[],int low,int up)
{
    int mid;
    int temp[MAX];

    if(low==up) // stop if having only one element.
	return;
    mid=(low+up)/2;

    mergesort(a,low,mid); //sort a[low] to a mid.
    mergesort(a,mid+1,up);//sort a[mid+1] to up.

    /* Merge a[low]...a[mid],and a[mid+1]....a[up],to temp[low]...temp[up2] */
    merge(a,temp,low,mid,mid+1,up);

    /*Copy temp[low]....temp[up],to a[low] and a[up] */
    copy(a,temp,low,up);
}

/* a[low1]...a[up1], and a[low2]...a[up2],merged to temp[low1]...temp[up2]*/
/*  If single array has two sorted parts. */
void merge(int a[],int temp[],int low1,int up1,int low2,int up2)
{
    int i= low1;
    int j= low2;
    int k= low1;

    while((i<=up1)&&(j<=up2))
    {
	if(a[i]<a[j])
	    temp[k++]=a[i++];
	else
	    temp[k++]=a[j++];
    }
    //Coping remaning elements of a1,if a2 is finished.
    while(i<=up1)
	temp[k++]=a[i++];
    //Coping remaining elements of a2,if a1 is finished.
    while(j<=up2)
	temp[k++]=a[j++];
}

void copy(int a[],int temp[],int low,int up)
{
    int i;
    for(i=low;i<=up;i++)
	a[i]=temp[i];
}

5. Merge sort in java

	public static void main(String[] args) {
        int[] intArray = { 20, 35, -15, 7, 55, 1, -22 };

        mergeSort(intArray, 0, intArray.length);

        for (int i = 0; i < intArray.length; i++) {
            System.out.println(intArray[i]);
        }
    }

    // { 20, 35, -15, 7, 55, 1, -22 }
    public static void mergeSort(int[] input, int start, int end) {

        if (end - start < 2) {
            return;
        }

        int mid = (start + end) / 2;
        mergeSort(input, start, mid);
        mergeSort(input, mid, end);
        merge(input, start, mid, end);
    }

    // { 20, 35, -15, 7, 55, 1, -22 }
    public static void merge(int[] input, int start, int mid, int end) {

        if (input[mid - 1] <= input[mid]) {
            return;
        }

        int i = start;
        int j = mid;
        int tempIndex = 0;

        int[] temp = new int[end - start];
        while (i < mid && j < end) {
            temp[tempIndex++] = input[i] <= input[j] ? input[i++] : input[j++];
        }

            /**Copy remaining element of left array to input array**/
        System.arraycopy(input, i, input, start + tempIndex, mid - i);
            /**Don't need to copy element of right array  from input to temp and again to input. So simply copy left 		array**/
        System.arraycopy(temp, 0, input, start, tempIndex);
    }

6. Merge Sort in java with jenny

public class MergeSortJ {

    private static int listToSort[] = new int[] {3, 5, 6, 8, 10, 1, 2, 4, 7, 9};
    public static void main(String[] args) {
        print(listToSort);
        mergeSort(listToSort);
    }

    public static void print(int[] listToSort) {
        for (int el : listToSort) {
            System.out.print(el + ",");
        }
        System.out.println();
    }

    public static void mergeSort(int[] listToSort) {
        if (listToSort.length == 1) {
            return;
        }

        int midIndex = listToSort.length / 2 + listToSort.length % 2;
        int[] listFirstHalf = new int[midIndex];
        int[] listSecondHalf = new int[listToSort.length - midIndex];
        split(listToSort, listFirstHalf, listSecondHalf);

        mergeSort(listFirstHalf);
        mergeSort(listSecondHalf);

        merge(listToSort, listFirstHalf, listSecondHalf);
        print(listToSort);
    }

    public static void split(int[] listToSort, int[] listFirstHalf, int[] listSecondHalf) {
        int index = 0;
        int secondHalfStartIndex = listFirstHalf.length;
        for (int elements : listToSort) {
            if (index < secondHalfStartIndex) {
                listFirstHalf[index] = listToSort[index];
            } else {
                listSecondHalf[index - secondHalfStartIndex] = listToSort[index];
            }
            index++;
        }
    }

    public static void merge(int[] listToSort, int[] listFirstHalf, int[] listSecondHalf) {
        int mergeIndex = 0;
        int firstHalfIndex = 0;
        int secondHalfIndex = 0;

        while (firstHalfIndex < listFirstHalf.length && secondHalfIndex < listSecondHalf.length) {
            if (listFirstHalf[firstHalfIndex] < listSecondHalf[secondHalfIndex]) {
                listToSort[mergeIndex] = listFirstHalf[firstHalfIndex];
                firstHalfIndex++;
            } else if (secondHalfIndex < listSecondHalf.length) {
                listToSort[mergeIndex] = listSecondHalf[secondHalfIndex];
                secondHalfIndex++;
            }
            mergeIndex++;
        }

        if (firstHalfIndex < listFirstHalf.length) {
            while (mergeIndex < listToSort.length) {
                listToSort[mergeIndex++] = listFirstHalf[firstHalfIndex++];
            }
        }
        if (secondHalfIndex < listSecondHalf.length) {
            while (mergeIndex < listToSort.length) {
                listToSort[mergeIndex++] = listSecondHalf[secondHalfIndex++];
            }
        }
    }
}

7. Quick Sort:-In-Place Algorithm,Run time complexity O(nLogn)base 2. It is unstable sort.

#include<stdio.h>
#include<conio.h>
#define MAX 100

void quicksort(int a[],int low,int up);
int  partition(int a[],int low,int up);



void main()
{
    int a[MAX],n,i;

    printf("Enter the no of elements in  array: ");
    scanf("%d",&n);

    for(i=0;i<n;i++)
    {
       printf("Enter the element %d :",i+1);
       scanf("%d",&a[i]);
    }

    quicksort(a,0,n-1);
    printf("Sorted list  is: \n");
    for(i=0;i<n;i++)
     printf("%d ",a[i]);
     printf("\n");

getch();
}

void quicksort(int a[],int low,int up)
{
    int p; /**Index of pivot**/
    if(low>=up)  /**Zero or one elelment in the sublist**/
	return;
    p = partition(a,low,up);
    quicksort(a,low,p-1); /**Sort left sublist***/
    quicksort(a,p+1,up); /**Sort right sublist**/
}

int partition(int a[],int low,int up)
{
    int temp,i,j,pivot;

    pivot=a[low];

    i=low+1;   // Moves from left to right.
    j=up;      // Moves from right to left.

    while(i<=j)
    {
	while(a[i]< pivot && i<up)
	    i++;
	while(a[j]>pivot)
	    j--;
	if(i<j) /**Swap a[i] and a[j]**/
	{
	    temp=a[i];
	    a[i]=a[j];
	    a[j]=temp;
	    i++;
	    j--;
	}
	else
	      break;   //Found proper place for pivot.
    }
    //Proper place for pivot is j.
    a[low]=a[j];
    a[j]=pivot;
    return j; 
}


